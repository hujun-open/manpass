#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6.3 on Thu Apr 15 22:20:13 2010


import json
import pyscrypt
import nacl
import nacl.secret
import nacl.utils
import nacl.encoding
import nacl.hash
import M2Crypto

KeySize   = 32
NonceSize = 24
SaltSize  = 16
Scrypt_N  = 1024
Scrypt_r  = 1
Scrypt_p  = 1

PassCardDBreakLine=":::::::::::::::::::::::::::::::::::::::::::::::::::::::"
MACALG="sha256"

def GenerateSalt():
    return nacl.utils.random(SaltSize)

def GenerateEncKey(passwd, salt):
    enc_key=pyscrypt.hash(password=passwd,
        salt = salt,
        N=Scrypt_N,
        r=Scrypt_r,
        p=Scrypt_p,
        dkLen=KeySize)
    return enc_key

def GenerateNonce():
    return nacl.utils.random(NonceSize)


def EncryptWithoutSalt(msg,skey):
    nonce=GenerateNonce()
    box = nacl.secret.SecretBox(skey)
    cipher_txt=box.encrypt(msg,nonce)
    return cipher_txt

def DecryptWithoutSalt(cipher,skey):
    box = nacl.secret.SecretBox(skey)
    return box.decrypt(cipher)

def EncryptMe(msg, passwd):
    salt=GenerateSalt()
    skey=GenerateEncKey(passwd,salt)
    rstr=EncryptWithoutSalt(msg,skey)
    return salt+rstr

def DecryptMe(cipher,passwd):
    salt=cipher[:SaltSize]
    skey=GenerateEncKey(passwd,salt)
    return DecryptWithoutSalt(cipher[SaltSize:],skey)

def EncryptMeBase32(msg,passwd):
    cipher=EncryptMe(msg,passwd)
    enc=nacl.encoding.Base32Encoder()
    return enc.encode(cipher)

def EncryptWithoutSaltBase32(msg,skey,salt):
    cipher=EncryptWithoutSalt(msg,skey)
    enc=nacl.encoding.Base32Encoder()
    return enc.encode(salt+cipher)

def DecryptMeBase32(cipher,passwd):
    enc=nacl.encoding.Base32Encoder()
    return DecryptMe(enc.decode(cipher),passwd)



def HashMsg(msg,skey):
    h=nacl.hash.sha256(skey+msg)
    return h+msg

def VerifyHash(msg,skey):
    if len(msg)<=64:
        return False
    h=msg[0:64]
    nh=nacl.hash.sha256(skey+msg[64:])
    if nh==h:
        return msg[64:]
    else:
        return False

def breakLine(longline,sep):
    pos=0
    if isinstance(sep,str):
        step=len(sep)
    else:
        step=sep
    llen=len(longline)
    rs=""
    while pos<llen:
        rs+=longline[pos:pos+step]
        rs+="\n"
        pos+=step
    return rs


def getPassCard(privk_file_name,uname,upass):
    """return a str with following format with following parts (each part is seperated by PassCardDBreakLine)
        - uname
        - pubkey.e in b32
        - pubkey.n in b32
        - the signature of above in b32 (with MAC=MACALG)
    """
    global PassCardDBreakLine,MACALG
    enc=nacl.encoding.Base32Encoder()
    def mypass(*args):
        return upass
    uname=uname.strip()
    rs=breakLine(uname,PassCardDBreakLine)+PassCardDBreakLine+"\n"
    rsak=M2Crypto.RSA.load_key(privk_file_name,mypass)
    (e,n)=rsak.pub()
    rs+=breakLine(enc.encode(e),PassCardDBreakLine)+PassCardDBreakLine+"\n"
    rs+=breakLine(enc.encode(n),PassCardDBreakLine)+PassCardDBreakLine+"\n"
    str_to_sign=uname+e+n
    MsgDigest = M2Crypto.EVP.MessageDigest(MACALG)
    MsgDigest.update(str_to_sign)
    sigs= rsak.sign_rsassa_pss(MsgDigest.digest(),MACALG)
    rs+=breakLine(enc.encode(sigs),PassCardDBreakLine)
    return rs


def parsePassCard(cards):
    """
    parse a PassCard str, return username and M2Crypto.RSA.RSA_pub instance
    if it is invalid, return False
    """
    global PassCardDBreakLine,MACALG
    rs=cards.replace("\n","")
    rs=rs.replace("\r","")
##    rs=rs.replace("\t","")
##    rs=rs.replace(" ","")
    (uname,e,n,sigs)=rs.split(PassCardDBreakLine,3)
    enc=nacl.encoding.Base32Encoder()
    e=enc.decode(e)
    n=enc.decode(n)
    pubk=M2Crypto.RSA.new_pub_key((e,n))
    sigs=enc.decode(sigs)
    str_to_sign=uname+e+n
    MsgDigest = M2Crypto.EVP.MessageDigest(MACALG)
    MsgDigest.update(str_to_sign)
    if pubk.verify_rsassa_pss(MsgDigest.digest(),sigs,MACALG)==False:
        return False
    return (uname,pubk)


def encPassRecord(pr,passwd):
    """
    return a str which is encrypted(by passwd) pass record in b32 format
    """
    js=json.dumps(pr)
    return EncryptMeBase32(js,passwd)

def decPassRecord(ciphr,passwd):
    rs=ciphr.replace("\n","")
    rs=ciphr.replace("\r","")
    js=DecryptMeBase32(rs,passwd)
    return json.loads(js)




if __name__ == '__main__':
    pr={"Uname":"Tom","Pass":"pass,123","Meta":"google.com","Kgroup":u"好的","Remark":"this is a remark"}
    cs=encPassRecord(pr,"pass123")
    print breakLine(cs,50)
    print decPassRecord(cs,"pass123")